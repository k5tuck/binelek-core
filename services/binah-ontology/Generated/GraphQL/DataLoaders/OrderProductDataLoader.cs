// <auto-generated />
// Generated from SupplyChainOntology vv1.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using GreenDonut;
using HotChocolate.DataLoader;
using Acme.SupplyChain.Entities;
using Acme.SupplyChain.Repositories;

namespace Acme.SupplyChain.GraphQL.DataLoaders
{
    /// <summary>
    /// DataLoader for batch loading Product entities related to Order
    /// Orders contain multiple products
    /// Prevents N+1 query problems when resolving OrderContainsProducts relationship
    /// </summary>
    public class OrderProductDataLoader : BatchDataLoader<Guid, IEnumerable<Product>>
    {
        private readonly IProductRepository _repository;

        public OrderProductDataLoader(
            IProductRepository repository,
            IBatchScheduler batchScheduler,
            DataLoaderOptions? options = null)
            : base(batchScheduler, options)
        {
            _repository = repository ?? throw new ArgumentNullException(nameof(repository));
        }

        protected override async Task<IReadOnlyDictionary<Guid, IEnumerable<Product>>> LoadBatchAsync(
            IReadOnlyList<Guid> keys,
            CancellationToken cancellationToken)
        {
            // Batch fetch all Product entities related to the given Order IDs
            var entities = await _repository.GetByForeignKeyAsync("OrderId", keys, cancellationToken);

            // Group by the foreign key (OrderId)
            var grouped = entities
                .GroupBy(e => e.OrderId)
                .ToDictionary(
                    g => g.Key,
                    g => g.AsEnumerable());

            // Return results for all requested keys (empty collections for keys with no results)
            return keys.ToDictionary(
                key => key,
                key => grouped.ContainsKey(key) ? grouped[key] : Enumerable.Empty<Product>());
        }
    }
}
