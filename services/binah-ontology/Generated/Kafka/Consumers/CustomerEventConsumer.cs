// <auto-generated />
// Generated from SupplyChainOntology vv1.0.0

using System;
using System.Threading;
using System.Threading.Tasks;
using Confluent.Kafka;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Acme.SupplyChain.Kafka.Events;

namespace Acme.SupplyChain.Kafka.Consumers
{
    /// <summary>
    /// Background service that consumes Customer events from Kafka
    /// </summary>
    public class CustomerEventConsumer : BackgroundService
    {
        private readonly IConsumer<string, CustomerCreatedEvent> _createdConsumer;
        private readonly IConsumer<string, CustomerUpdatedEvent> _updatedConsumer;
        private readonly IConsumer<string, CustomerDeletedEvent> _deletedConsumer;
        private readonly ICustomerEventHandler _eventHandler;
        private readonly ILogger<CustomerEventConsumer> _logger;

        public CustomerEventConsumer(
            IConsumer<string, CustomerCreatedEvent> createdConsumer,
            IConsumer<string, CustomerUpdatedEvent> updatedConsumer,
            IConsumer<string, CustomerDeletedEvent> deletedConsumer,
            ICustomerEventHandler eventHandler,
            ILogger<CustomerEventConsumer> logger)
        {
            _createdConsumer = createdConsumer ?? throw new ArgumentNullException(nameof(createdConsumer));
            _updatedConsumer = updatedConsumer ?? throw new ArgumentNullException(nameof(updatedConsumer));
            _deletedConsumer = deletedConsumer ?? throw new ArgumentNullException(nameof(deletedConsumer));
            _eventHandler = eventHandler ?? throw new ArgumentNullException(nameof(eventHandler));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("CustomerEventConsumer starting...");

            // Subscribe to topics
            _createdConsumer.Subscribe(KafkaTopics.OntologyEntityCreated);
            _updatedConsumer.Subscribe(KafkaTopics.OntologyEntityUpdated);
            _deletedConsumer.Subscribe(KafkaTopics.OntologyEntityDeleted);

            try
            {
                // Run all consumers concurrently
                await Task.WhenAll(
                    ConsumeCreatedEventsAsync(stoppingToken),
                    ConsumeUpdatedEventsAsync(stoppingToken),
                    ConsumeDeletedEventsAsync(stoppingToken)
                );
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("CustomerEventConsumer stopping...");
            }
            finally
            {
                _createdConsumer.Close();
                _updatedConsumer.Close();
                _deletedConsumer.Close();
                _logger.LogInformation("CustomerEventConsumer stopped");
            }
        }

        private async Task ConsumeCreatedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _createdConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing CustomerCreated event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleCreatedEventAsync(result.Message.Value, stoppingToken);

                        _createdConsumer.Commit(result);
                        _logger.LogInformation("CustomerCreated event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming CustomerCreated event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing CustomerCreated event");
                }
            }
        }

        private async Task ConsumeUpdatedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _updatedConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing CustomerUpdated event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleUpdatedEventAsync(result.Message.Value, stoppingToken);

                        _updatedConsumer.Commit(result);
                        _logger.LogInformation("CustomerUpdated event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming CustomerUpdated event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing CustomerUpdated event");
                }
            }
        }

        private async Task ConsumeDeletedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _deletedConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing CustomerDeleted event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleDeletedEventAsync(result.Message.Value, stoppingToken);

                        _deletedConsumer.Commit(result);
                        _logger.LogInformation("CustomerDeleted event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming CustomerDeleted event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing CustomerDeleted event");
                }
            }
        }
    }
}
