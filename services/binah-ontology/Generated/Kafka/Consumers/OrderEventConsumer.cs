// <auto-generated />
// Generated from SupplyChainOntology vv1.0.0

using System;
using System.Threading;
using System.Threading.Tasks;
using Confluent.Kafka;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Acme.SupplyChain.Kafka.Events;

namespace Acme.SupplyChain.Kafka.Consumers
{
    /// <summary>
    /// Background service that consumes Order events from Kafka
    /// </summary>
    public class OrderEventConsumer : BackgroundService
    {
        private readonly IConsumer<string, OrderCreatedEvent> _createdConsumer;
        private readonly IConsumer<string, OrderUpdatedEvent> _updatedConsumer;
        private readonly IConsumer<string, OrderDeletedEvent> _deletedConsumer;
        private readonly IOrderEventHandler _eventHandler;
        private readonly ILogger<OrderEventConsumer> _logger;

        public OrderEventConsumer(
            IConsumer<string, OrderCreatedEvent> createdConsumer,
            IConsumer<string, OrderUpdatedEvent> updatedConsumer,
            IConsumer<string, OrderDeletedEvent> deletedConsumer,
            IOrderEventHandler eventHandler,
            ILogger<OrderEventConsumer> logger)
        {
            _createdConsumer = createdConsumer ?? throw new ArgumentNullException(nameof(createdConsumer));
            _updatedConsumer = updatedConsumer ?? throw new ArgumentNullException(nameof(updatedConsumer));
            _deletedConsumer = deletedConsumer ?? throw new ArgumentNullException(nameof(deletedConsumer));
            _eventHandler = eventHandler ?? throw new ArgumentNullException(nameof(eventHandler));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("OrderEventConsumer starting...");

            // Subscribe to topics
            _createdConsumer.Subscribe(KafkaTopics.OntologyEntityCreated);
            _updatedConsumer.Subscribe(KafkaTopics.OntologyEntityUpdated);
            _deletedConsumer.Subscribe(KafkaTopics.OntologyEntityDeleted);

            try
            {
                // Run all consumers concurrently
                await Task.WhenAll(
                    ConsumeCreatedEventsAsync(stoppingToken),
                    ConsumeUpdatedEventsAsync(stoppingToken),
                    ConsumeDeletedEventsAsync(stoppingToken)
                );
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("OrderEventConsumer stopping...");
            }
            finally
            {
                _createdConsumer.Close();
                _updatedConsumer.Close();
                _deletedConsumer.Close();
                _logger.LogInformation("OrderEventConsumer stopped");
            }
        }

        private async Task ConsumeCreatedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _createdConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing OrderCreated event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleCreatedEventAsync(result.Message.Value, stoppingToken);

                        _createdConsumer.Commit(result);
                        _logger.LogInformation("OrderCreated event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming OrderCreated event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing OrderCreated event");
                }
            }
        }

        private async Task ConsumeUpdatedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _updatedConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing OrderUpdated event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleUpdatedEventAsync(result.Message.Value, stoppingToken);

                        _updatedConsumer.Commit(result);
                        _logger.LogInformation("OrderUpdated event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming OrderUpdated event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing OrderUpdated event");
                }
            }
        }

        private async Task ConsumeDeletedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _deletedConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing OrderDeleted event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleDeletedEventAsync(result.Message.Value, stoppingToken);

                        _deletedConsumer.Commit(result);
                        _logger.LogInformation("OrderDeleted event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming OrderDeleted event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing OrderDeleted event");
                }
            }
        }
    }
}
