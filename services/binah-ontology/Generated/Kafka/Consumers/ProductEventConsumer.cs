// <auto-generated />
// Generated from SupplyChainOntology vv1.0.0

using System;
using System.Threading;
using System.Threading.Tasks;
using Confluent.Kafka;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Acme.SupplyChain.Kafka.Events;

namespace Acme.SupplyChain.Kafka.Consumers
{
    /// <summary>
    /// Background service that consumes Product events from Kafka
    /// </summary>
    public class ProductEventConsumer : BackgroundService
    {
        private readonly IConsumer<string, ProductCreatedEvent> _createdConsumer;
        private readonly IConsumer<string, ProductUpdatedEvent> _updatedConsumer;
        private readonly IConsumer<string, ProductDeletedEvent> _deletedConsumer;
        private readonly IProductEventHandler _eventHandler;
        private readonly ILogger<ProductEventConsumer> _logger;

        public ProductEventConsumer(
            IConsumer<string, ProductCreatedEvent> createdConsumer,
            IConsumer<string, ProductUpdatedEvent> updatedConsumer,
            IConsumer<string, ProductDeletedEvent> deletedConsumer,
            IProductEventHandler eventHandler,
            ILogger<ProductEventConsumer> logger)
        {
            _createdConsumer = createdConsumer ?? throw new ArgumentNullException(nameof(createdConsumer));
            _updatedConsumer = updatedConsumer ?? throw new ArgumentNullException(nameof(updatedConsumer));
            _deletedConsumer = deletedConsumer ?? throw new ArgumentNullException(nameof(deletedConsumer));
            _eventHandler = eventHandler ?? throw new ArgumentNullException(nameof(eventHandler));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("ProductEventConsumer starting...");

            // Subscribe to topics
            _createdConsumer.Subscribe(KafkaTopics.OntologyEntityCreated);
            _updatedConsumer.Subscribe(KafkaTopics.OntologyEntityUpdated);
            _deletedConsumer.Subscribe(KafkaTopics.OntologyEntityDeleted);

            try
            {
                // Run all consumers concurrently
                await Task.WhenAll(
                    ConsumeCreatedEventsAsync(stoppingToken),
                    ConsumeUpdatedEventsAsync(stoppingToken),
                    ConsumeDeletedEventsAsync(stoppingToken)
                );
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("ProductEventConsumer stopping...");
            }
            finally
            {
                _createdConsumer.Close();
                _updatedConsumer.Close();
                _deletedConsumer.Close();
                _logger.LogInformation("ProductEventConsumer stopped");
            }
        }

        private async Task ConsumeCreatedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _createdConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing ProductCreated event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleCreatedEventAsync(result.Message.Value, stoppingToken);

                        _createdConsumer.Commit(result);
                        _logger.LogInformation("ProductCreated event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming ProductCreated event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing ProductCreated event");
                }
            }
        }

        private async Task ConsumeUpdatedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _updatedConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing ProductUpdated event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleUpdatedEventAsync(result.Message.Value, stoppingToken);

                        _updatedConsumer.Commit(result);
                        _logger.LogInformation("ProductUpdated event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming ProductUpdated event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing ProductUpdated event");
                }
            }
        }

        private async Task ConsumeDeletedEventsAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var result = _deletedConsumer.Consume(stoppingToken);

                    if (result?.Message != null)
                    {
                        _logger.LogInformation("Processing ProductDeleted event for {EntityId}",
                            result.Message.Value.EntityId);

                        await _eventHandler.HandleDeletedEventAsync(result.Message.Value, stoppingToken);

                        _deletedConsumer.Commit(result);
                        _logger.LogInformation("ProductDeleted event processed successfully");
                    }
                }
                catch (ConsumeException ex)
                {
                    _logger.LogError(ex, "Error consuming ProductDeleted event");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing ProductDeleted event");
                }
            }
        }
    }
}
